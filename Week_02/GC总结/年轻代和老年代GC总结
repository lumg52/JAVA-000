一：GC算法
1：引用计数算法
在对象创建的时候绑定一个计数器，当有一个引用指向该对象时，计数器+1，当一个引用被删除，计数器-1，计数器为0，对象死亡要回收

2：标记–清除算法
为每个对象加一个标记位（记录对象的状态）。标记步骤，更新每个对象的状态；清除步骤，清除标记为死亡的对象（执行GC）

3：标记-整理算法
标记-清除的改进版，清除阶段让所有的标记存活的对象向一边移动，直接清理掉边界以外的内存，提高清除效率

4：分代收集
年轻代使用复制算法，老年代使用标记-清理或标记-整理算法

二：年轻代GC收集器

1：串行收集器（-XX:+UseSerialGC）
是一个单线程收集器，一般在主机是单CPU情况下使用，GC效率高（因为独占cpu），GC会STW（GC多会经常停顿）
使用算法：

2：并发收集器（-XX:+UseParNewGC）
是串行收集器的多线程版本，在串行收集器上多了线程交互使用cpu，在多cpu的情况下比串行算法GC效率高。一般用来与老年代CMS收集器配合使用
使用算法：

3：并行收集器（-XX:+UseParallelGC）
被称为“吞吐量优先”收集器，使用多线程用于加速垃圾收集，高效运用cpu时间。相比并发收集器，具有自适应调节机制 最大暂停时间>吞吐量>最小堆空间
使用算法：

三：老年代GC收集器

1：Serial Old收集器（-XX:+UseSerialGC）
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器
使用算法：

2：Parallel Old收集器（）
和年轻代并行收集器配合，更高效利用多cpu，提高吞吐量
使用算法：

3：CMS收集器（）：
Concurrent Mark Sweep，CMS的目标是获取最短回收停顿时间，将GC过程分为初始标记-并发标记-重新标记-并发清除，只有两个标记阶段需要STW，所以停顿时间少；
使用算法：

4：G1收集器（-XX:+UseG1GC）
为了解决CMS算法产生空间碎片问题，一般用在多cpu大内存情况下。G1将堆分成多个大小相等的内存块（region），每个region是连续的一段内存，每个region的大小只能是1M、2M、4M（2的次幂），默认是2048个region
可预测停顿时间
使用算法：

5：ZGC（用在超大内存场景）
GC 最大停顿时间不超过 10ms

配合使用场景：
ParNewGC + CMS 适用低延迟
ParallelGC + ParllelGC Old  适用高吞吐量

G1：有GC时间指标的时候


